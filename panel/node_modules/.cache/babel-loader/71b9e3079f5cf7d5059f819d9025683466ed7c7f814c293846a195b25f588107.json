{"ast":null,"code":"'use strict';\n\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(\"Format functions must be synchronous taking a two arguments: (info, opts)\\nFound: \".concat(formatFn.toString().split('\\n')[0], \"\\n\"));\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n}\n\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n  function Format() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = options;\n  }\n  Format.prototype.transform = formatFn;\n\n  //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  }\n\n  //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};","map":{"version":3,"names":["InvalidFormatError","Error","constructor","formatFn","concat","toString","split","captureStackTrace","module","exports","length","Format","options","arguments","undefined","prototype","transform","createFormatWrap","opts"],"sources":["/home/kira/panel/node_modules/logform/format.js"],"sourcesContent":["'use strict';\n\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n}\n\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n  function Format(options = {}) {\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn;\n\n  //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  }\n\n  //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA,MAAMA,kBAAkB,SAASC,KAAK,CAAC;EACrCC,WAAWA,CAACC,QAAQ,EAAE;IACpB,KAAK,sFAAAC,MAAA,CACAD,QAAQ,CAACE,QAAQ,CAAC,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAI,CAAC;IAE5CL,KAAK,CAACM,iBAAiB,CAAC,IAAI,EAAEP,kBAAkB,CAAC;EACnD;AACF;;AAEA;AACA;AACA;AACA;AACAQ,MAAM,CAACC,OAAO,GAAGN,QAAQ,IAAI;EAC3B,IAAIA,QAAQ,CAACO,MAAM,GAAG,CAAC,EAAE;IACvB,MAAM,IAAIV,kBAAkB,CAACG,QAAQ,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASQ,MAAMA,CAAA,EAAe;IAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAC1B,IAAI,CAACD,OAAO,GAAGA,OAAO;EACxB;EAEAD,MAAM,CAACI,SAAS,CAACC,SAAS,GAAGb,QAAQ;;EAErC;EACA;EACA;EACA;EACA;EACA;EACA,SAASc,gBAAgBA,CAACC,IAAI,EAAE;IAC9B,OAAO,IAAIP,MAAM,CAACO,IAAI,CAAC;EACzB;;EAEA;EACA;EACA;EACA;EACAD,gBAAgB,CAACN,MAAM,GAAGA,MAAM;EAChC,OAAOM,gBAAgB;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}